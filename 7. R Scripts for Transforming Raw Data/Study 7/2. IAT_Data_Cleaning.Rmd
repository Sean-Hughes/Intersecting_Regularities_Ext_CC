---
title: "Cleaning IAT Data"
author: "Sean Hughes"
date: "30-5-2020"
output: 
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes 
    toc_float: yes
---

```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      warning=FALSE)
```


# Load the necessary packages

```{r}
library(ggthemes)
library(foreign)
library(tidyverse)
library(Hmisc)
library(car)
library(readxl)
library(xlsx)
library(IATscores)
```

## 1. Import the raw data files from Excel into R

```{r}

getwd()

wd <- list()
wd$data_AQ   <- "C:/Users/Sean/Desktop/Intersecting_Regularties_/Study 7/Raw_Data/1_Acquisition_Only_Data/"
wd$data_CC   <- "C:/Users/Sean/Desktop/Intersecting_Regularties_/Study 7/Raw_Data/2_Counterconditioning_Data/"
wd$data_EX   <- "C:/Users/Sean/Desktop/Intersecting_Regularties_/Study 7/Raw_Data/3_Extinction_Data/"

wd$output <- "C:/Users/Sean/Desktop/Intersecting_Regularties_/Study 7/Processed_Data/"

# Acquisition Only Group Data
raw_IAT_data_AQ_1 <- read_xlsx(paste0(wd$data_AQ, "iat_symbols_before_17_06_20.xlsx"), col_names = TRUE)
raw_IAT_data_AQ_2 <- read_xlsx(paste0(wd$data_AQ, "iat_symbols_after_17_06_20.xlsx"), col_names = TRUE)

# Counterconditioning Group Data

raw_IAT_data_CC_1 <- read_xlsx(paste0(wd$data_CC, "iat_symbols_before_raw.xlsx"), col_names = TRUE)
raw_IAT_data_CC_2 <- read_xlsx(paste0(wd$data_CC, "iat_symbols_after_raw.xlsx"), col_names = TRUE)
  
# Extinction Group Data

raw_IAT_data_EX_1 <- read_xlsx(paste0(wd$data_EX, "iat_symbols_before_19_04_05.xlsx"), col_names = TRUE)
raw_IAT_data_EX_2 <- read_xlsx(paste0(wd$data_EX, "iat_symbols_after_19_04_05.xlsx"), col_names = TRUE)

```

## 2. Join the raw IAT files together

```{r}

# apparently the $response can sometimes be a character (e.g., when someone presses CTRL + Q). So convert to a numeric
raw_IAT_data_AQ_1$response <- as.integer(raw_IAT_data_AQ_1$response)
raw_IAT_data_AQ_2$response <- as.integer(raw_IAT_data_AQ_2$response)

raw_IAT_data_CC_1$response <- as.integer(raw_IAT_data_CC_1$response)
raw_IAT_data_CC_2$response <- as.integer(raw_IAT_data_CC_2$response)

raw_IAT_data_EX_1$response <- as.integer(raw_IAT_data_EX_1$response)
raw_IAT_data_EX_2$response <- as.integer(raw_IAT_data_EX_2$response)

# Add information about the training condition to the IAT files 

raw_IAT_data_AQ_1 <- raw_IAT_data_AQ_1 %>%
  mutate(training_condition = "Acquisition_Only")

raw_IAT_data_AQ_2 <- raw_IAT_data_AQ_2 %>%
  mutate(training_condition = "Acquisition_Only")

raw_IAT_data_CC_1 <- raw_IAT_data_CC_1 %>%
  mutate(training_condition = "Counterconditioning")

raw_IAT_data_CC_2 <- raw_IAT_data_CC_2 %>%
  mutate(training_condition = "Counterconditioning")

raw_IAT_data_EX_1 <- raw_IAT_data_EX_1 %>%
  mutate(training_condition = "Extinction")

raw_IAT_data_EX_2 <- raw_IAT_data_EX_2 %>%
  mutate(training_condition = "Extinction")


# Combine the data files together

combined_IAT_data <- raw_IAT_data_AQ_1 %>% 
  bind_rows(raw_IAT_data_AQ_2, raw_IAT_data_CC_1, raw_IAT_data_CC_2, raw_IAT_data_EX_1, raw_IAT_data_EX_2) %>%
  rename(block_type = blockcode, block = blocknum, trial_number = trialnum) %>%
  select(subject, block_type, block, trial_number, correct, latency, training_condition) %>% 
    arrange(subject, block)

```

## 3. IAT Data Cleaning 

```{r}

# 1. identify and remove individuals with incomplete data 

complete_IAT_data <- combined_IAT_data %>%
  group_by(subject, training_condition) %>%
  summarise(trial_count = n()) %>%
  filter(trial_count == 180) %>%
  ungroup() 

processed_IAT_data <- combined_IAT_data %>%
# trial_number on blocks 3 and 7 begins on 2. So delete 1 from trial_number in these two blocks so that trial_number begins at 1
 mutate(trial_number = ifelse(block == 1 | block == 2 | block == 3 | block == 6 | block == 7, trial_number-1, trial_number)) %>%

# the number of the blocks is incorrect. So renumber block 5 -> 4, 6 -> 5, 7 -> 6, 9 -> 7
 mutate(block = ifelse(block == 5, 4, block)) %>%
 mutate(block = ifelse(block == 6, 5, block)) %>%
 mutate(block = ifelse(block == 7, 6, block)) %>%
 mutate(block = ifelse(block == 9, 7, block)) 


# 2. Identify IAT block order for later analysis

IAT_order <- processed_IAT_data %>% 
  mutate(IAT_order = ifelse(block == 1 & block_type == "targetincompatiblepractice", "Learning_Inconsistent_First", "Learning_Consistent_First")) %>% 
  rename(ID = subject) %>%
  group_by(ID, training_condition) %>% 
  select(ID, IAT_order) %>%
  slice(1)

# 3. only retain the critical practice and test blocks (i.e., block_number = 3, 4, 6, 7)

processed_IAT_data <- processed_IAT_data %>% 
  filter(block == 3 | block == 4 | block == 6 | block == 7) %>% 
  arrange(subject, block) 
  

# 4. identify participants who have a total error rate > 30% (i.e., > 36 trials incorrect) 

    # 4.1 in the Acquisition Only group

processed_IAT_data_AQ <- processed_IAT_data %>% 
  filter(training_condition == "Acquisition_Only")

total_error_AQ <- processed_IAT_data_AQ %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 35) %>%
  ungroup()

processed_IAT_data_AQ <- processed_IAT_data_AQ %>%
  filter(!subject %in% total_error_AQ$subject)


    # 4.2 in the Counterconditioning group

processed_IAT_data_CC <- processed_IAT_data %>% 
  filter(training_condition == "Counterconditioning")

total_error_CC <- processed_IAT_data_CC %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 35) %>%
  ungroup()

processed_IAT_data_CC <- processed_IAT_data_CC %>%
  filter(!subject %in% total_error_CC$subject)


    # 4.3 in the Extinction group

processed_IAT_data_EX <- processed_IAT_data %>% 
  filter(training_condition == "Extinction")

total_error_EX <- processed_IAT_data_EX %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 35) %>%
  ungroup()

processed_IAT_data_EX <- processed_IAT_data_EX %>%
  filter(!subject %in% total_error_EX$subject)

    # 4.4 Combined the cleaned files back together again

processed_IAT_data <- processed_IAT_data_AQ %>%
  bind_rows(processed_IAT_data_CC, processed_IAT_data_EX) 


# 5. identify and remove participants who make more than 40% errors on any given block of trials (i.e., 8 errors on blocks 3 and 7 and 16 on blocks 5 and 9)
  

# 5.1 Block 3

  block_3_error <- processed_IAT_data %>% 
  filter(block == 3) %>%
  group_by(subject, training_condition, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 7) %>%
  ungroup()

  processed_IAT_data <- processed_IAT_data %>%
  filter(!subject %in% block_3_error)
  
  block_4_error <- processed_IAT_data %>% 
  filter(block == 4) %>%
  group_by(subject, training_condition, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 15) %>%
  ungroup()

  processed_IAT_data <- processed_IAT_data %>%
  filter(!subject %in% block_4_error)
  
  
  # 5.2 Block 6 - turns out there are individuals to be removed because of Block 6
  
  block_6_error <- processed_IAT_data_AQ %>% 
  filter(block == 6) %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 7) %>%
  ungroup()

  processed_IAT_data_AQ <- processed_IAT_data_AQ %>%
  filter(!subject %in% block_6_error$subject)
  
  block_6_error <- processed_IAT_data_CC %>% 
  filter(block == 6) %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 7) %>%
  ungroup()

  processed_IAT_data_CC <- processed_IAT_data_CC %>%
  filter(!subject %in% block_6_error$subject)
  
  # 5.3 Block 7 - turns out there are individuals to be removed beacuse of Block 7 
  
  block_7_error <- processed_IAT_data_AQ %>% 
  filter(block == 7) %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 15) %>%
  ungroup()
  
  processed_IAT_data_AQ <- processed_IAT_data_AQ %>%
  filter(!subject %in% block_7_error$subject)
  
  block_7_error <- processed_IAT_data_CC %>% 
  filter(block == 7) %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 15) %>%
  ungroup()
  
  processed_IAT_data_CC <- processed_IAT_data_CC %>%
  filter(!subject %in% block_7_error$subject)

  block_7_error <- processed_IAT_data_EX %>% 
  filter(block == 7) %>%
  group_by(subject, correct) %>% 
  summarise(error = n()) %>%
  filter(correct == 0 & error > 15) %>%
  ungroup()
  
  processed_IAT_data_EX <- processed_IAT_data_EX %>%
  filter(!subject %in% block_7_error$subject)
  
# 6. identify and remove participants with excessively fast trials: >10% (i.e., more than 12 trials where response latency is less than 300ms)
  
  speed <- processed_IAT_data %>% 
  filter(latency < 300) %>%
  group_by(subject, latency) %>% 
  summarise(count = n()) %>% 
  filter(count > 11) %>%
  ungroup
    
  processed_IAT_data <- processed_IAT_data %>%
  filter(!subject %in% speed$subject)
  
  
#7. Combine cleaned files 
  processed_IAT_data <- processed_IAT_data_AQ %>%
  bind_rows(processed_IAT_data_CC, processed_IAT_data_EX) 
  
# 4.5 Clean up the global environment  
rm(processed_IAT_data_AQ, processed_IAT_data_CC, processed_IAT_data_EX, total_error_AQ, total_error_CC, total_error_EX, block_3_error, block_4_error, block_6_error, block_7_error)
  
  
```


## 4. Calculating IAT scores (D2) using the IATscores package


```{r}

# IATscores package requires block_pair1 and block_pair2 to be factors or strings. So convert numerical block_number to factor

data_IAT_D2_scores <- processed_IAT_data %>%
  rename(ID = subject) %>%
  mutate(praccrit = ifelse(block_type == "incompatibletest1" | block_type == "compatibletest1", "prac", "crit")) %>%
  mutate(blockcode = ifelse(block_type == "incompatibletest1" | block_type == "incompatibletest2", "incompatible_block","compatible_block")) %>%
  select(ID, block, correct, latency, praccrit,  trial_number, block_type) %>%

  # IATscores requires data to be in a specific format
  mutate(blockcode = ifelse(block %in% c(3, 4), "pair1", 
                            ifelse(block %in% c(6, 7), "pair2", NA)),
         praccrit = ifelse(block %in% c(3, 6), "prac", 
                            ifelse(block %in% c(4, 7), "crit", NA)))  %>%
  rename(subject = ID) %>%
  filter(!is.na(blockcode)) %>%
  
  # calculate D2 scores
  # parameters are identical to those the package lists in the D2 wrapper function
  IATscores::RobustScores(IATdata = .,
                          P1 = "fxtrim",    # do not trim extreme values
                          P2 = "ignore",  # do not trim errors
                          P3 = "dscore",  # calculate d2 scores
                          P4 = "dist",    # distinguish between the prac and test blocks
                          verbose = FALSE,
                          autoremove = FALSE)  %>%
    rename(IAT_D2 = p2112,
           ID = subject) 

data_IAT_D2_scores <- data_IAT_D2_scores %>% 
  full_join(IAT_order, by = "ID") %>% 
  drop_na()

# It seems that the IATscores package is reversing the direction of the IAT scores for those participants in the "inconsistent learning block first" condition (this can be seen by inspecting the raw IAT data). To correct this error I've reverse scored the IAT scores for those in the inconsistent first IAT block order. The scores now correspond to the raw IAT data and the D IAT scores in the raw IAT files. 

data_IAT_D2_scores <- data_IAT_D2_scores %>% 
  mutate(Reverse_Scored_IAT_D2 = ifelse(IAT_order == "Learning_Inconsistent_First", IAT_D2 * -1, IAT_D2))

```

## 5. Write IAT scores to csv file

```{r}

write_csv2(as.data.frame(data_IAT_D2_scores), path = paste0(wd$output, "Study_7_IAT_Scores.csv"))

```

